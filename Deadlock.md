## 死锁

### 一、 死锁产生：

#### 1. 实验结果

​	 ![Deadlock](https://github.com/14353429/ES2016_14353429/blob/master/image/Deadlock.png)

​	这个是在window上面跑出来的，count为20000。在linux中调不出来。		

#### 2. 实验产生死锁的原因

​	主函数的时间轴是：每个循环都会创建一个新的线程t，然后开始运行，在队列中排队等待被调度。从截图可以看出来，在while循环中，线程就被调度了，循环结束才调用methodA。但是因为随着循环，创建的线程越来越多，总会出现一种情况：a.methodA(b)和b.methodB(a)同时执行了，分别去调用对方的synchronized void last()函数，但是在各自的method函数(也是synchronized类型)没有结束的时候，别的线程是无法访问自身其它的synchronized同步方法。这样就相当于大家都占有自己的资源，却又同时想申请别人的资源，因此产生了死锁。

### 二、 产生死锁的4个必要条件

#### 1. 资源互斥

​	一个资源只能让一个进程占有。

#### 2. 占有性等待

​	一个进程在占有资源的同时申请另外的资源。

#### 3. 不可抢占

​	申请资源的进程不能强行抢占当前已经被其它进程占有的资源。

#### 4. 循环等待

​	若干个进程之间形成一种头尾相接的循环等待资源的关系。

